<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<title>rotations</title>

<base target="_blank"/>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
}

pre code {
   display: block; padding: 0.5em;
}

code.r {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>



<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<h1>rotations</h1>

<h1></h1>

<p>This package implements tools for working with rotational data: it allows simulation from the most commonly used distributions on the sphere, it estimates different mean and median type estimators for the main direction of a number of rotations, it provides (bootstrap) confidence regions for the estimates, and it allows to visualize rotational data.</p>

<h2>Installation</h2>

<p>To install in your R session use:</p>

<pre><code>library(devtools)
install_github(&quot;rotations&quot;,&quot;heike&quot;) #Do this once
library(rotations)
</code></pre>

<h2>Data generation</h2>

<p>Three-dimensional rotations are determined uniquely by three numbers: two to define an axis and one to specify the rotation of all three dimensions about that axis.  This package follows the uniform-axis random-spin (<em>UARS</em>) framework of Bingham et al (2009) in simulating the axis and angle of rotation independently.  As the UARS name suggests, the axis, sometimes called the <em>misorientation axis</em> is chosen uniformly on the unit sphere and the angle of rotation, sometimes called the <em>misorientation angle</em>, is choose according to some circular distribution symmetric about zero and in the interval \( [-\pi,\pi) \).  The distribution chosen is usually referred to as the <em>angular distribution</em> as it describes the distributions of the misorientation angles.</p>

<p>To date there are three angular distributions from which to choose and three parameterizations of rotations.  The former are the von Mises circular, the Cayley and the von Mises-Fisher matrix distributions.  One can describe a rotation in a 3-by-3 <em>rotation matrix</em>, a four dimensional vector with unit length called a <em>quaternion</em> or a three-dimensional vector called and <em>Euler angle</em>.  Each will be described below. </p>

<h3>Misorientation angle simulation</h3>

<p>There are three angular distributions to simulate from.  They are all symmetric about zero and in the interval \( [-\pi,\pi) \).</p>

<ul>
<li><code>rvmises(n,kappa)</code> simulates data from the von Mises circular distributions</li>
<li><code>rcayley(n,kappa)</code> simulates data from the Cayley distributions</li>
<li><code>rfisher(n,kappa)</code> simulates data from the von Mises-Fisher matrix distribution</li>
</ul>

<h3>Rotation simulation</h3>

<p>Given a sample of n angles, use the <code>genR</code> function to simulate a rotation from the corresponding rotational distribution.  The default <em>central orientation</em>, or mean, is the identity but any rotation can be the central orientation and is specified by using the <code>S</code> option in <code>genR</code>.  The three parameterizations are considered next.</p>

<h4>Matrix parameterization</h4>

<p>When the <code>space</code> argument in <code>genR</code> is set to <code>SO3</code> then a 3-by-3 matrix is formed as described by Rodrigues&#39; formula.  Given axis \( u \) and angle \( r \) the <em>rotation matrix</em> \( R(u,r) \), or simply \( R \), is formed as follows:</p>

<p>\[ R=uu^\top+(I_{3\times 3}-uu^\top)\cos(r)+\Phi(u)\sin(r) \]</p>

<p>where <br/>
\[ \Phi(u)=\begin{pmatrix} 0 & -u_3 & u_2 \\ u_3 & 0 & -u_1\\ -u_2 & u_1 & 0\\ \end{pmatrix}. \] </p>

<p>If the <code>S</code> option is left to the default then \( R \) is returned, otherwise \( SR \) is returned</p>

<h4>Quaternion parameterization</h4>

<p>An alternative to the rotation matrix is the quaternion, which is chosen by settin the <code>space</code> option to <code>Q4</code>.  This formulation is typically popular with mathematicians and engineers.  Given the axis \( u \) and angle \( r \) the quaternion is formed as follows</p>

<p>\[ q=(\cos(r/2),\sin(r/2)u). \]</p>

<p>It&#39;s easy to see that a vector formed in such a fashion has unit length as \( q^\top q=\cos(r/2)^2+\sin(r/2)^2(u_1^2+u_2^2+u_3^2)=\cos(r/2)^2+\sin(r/2)^2=1 \).</p>

<h4>Euler angles</h4>

<p>We haven&#39;t decided on a favorite version of these yet so their functionality is limited.</p>

<h2>Central orientation estimation</h2>

<p>For any of the three parameterizations above four estimators of the central orientation are available from the following two functions.  In truth, the algorithms are written for the matrix parameterization so the quaternion and Euler angle versions reparameterize to matrices, find the mean or median then reperamaterize to the original form.</p>

<ul>
<li><p><code>median(Rs)</code> finds the rotation that minimizes the sum of first order distances from each sample point.  The <code>type</code> option allows the user to choose the Riemannian or Euclidean geometry to find the corresponding median-type estimator called the <em>intrinsic</em> or <em>projected</em> median respectively.  The algorithm used to compute the intrinsic median is described in Hartley et al. (2011).   Because the algorithms are iterative the <code>epsilon</code> and <code>maxIter</code> values control when convergence is reached or when to stop. </p></li>
<li><p><code>mean(Rs)</code> finds the rotation that minimizes the sum of second order distances from each sample point.  The <code>type</code>, <code>epsilon</code> and <code>maxIter</code> options work as described in <code>median</code> above.  For a discussion on the projected mean estimator see Moakher (2002) and the intrinsic mean is discussed in Manton (2004).</p></li>
</ul>

<h2>Visualization</h2>

<p>Based on <code>ggplot2</code> by Wickham (2009) we have developed a method for visualizing random rotations in SO(3) in three-dimensions.  The function <code>eyeBall</code> plots the data on the sphere along with all four estimators of the central orientation if the option <code>show.estimates</code> is set to <code>TRUE</code>.  By default the data are centered around  the three-dimensional identity matrix, but any matrix in SO(3) can be used as the center with the <code>center</code> option.  Finally, since only one column of the three is displayed at a time the <code>column</code> option allows the user to choose which column to display.  Additional options can be passed to the call to <code>qplot</code> too.</p>

</body>

</html>

